{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"note/list/","title":"List","text":""},{"location":"note/list/#linked-list","title":"linked list","text":"<p><pre><code>// Reverse a linked list\nq=h;\np=NUll;\nwhile(q){\n    t = q-&gt;next;\n    q-&gt;next = p;\n    p=q;\n    q=t;\n}\nh = p;\n\nLNode *reverse( LNode *head ){\n    LNode *p0,*head1;\n    head1=NULL;\n    for(p0=head-&gt;next;p0;){\n       LNode *temp=p0-&gt;next;//important!!!\n       p0-&gt;next =head1;\n       head1=p0;\n       p0=temp;\n    }\n    return head1;\n}\n</code></pre> * multilist * sparse matrix representation</p>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"FDS","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#sparse-matrix","title":"SPARSE MATRIX","text":"<p>Representing a sparse matrix by a 2D array leads to wastage of lots of memory as zeroes in the matrix are of no use in most of the cases. So, instead of storing zeroes with non-zero elements, we only store non-zero elements. This means storing non-zero elements with triples- (Row, Column, value).</p> <ul> <li>Using Array</li> </ul> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    // Assume 4x5 sparse matrix\n    int sparseMatrix[4][5] =\n    {\n        {0 , 0 , 3 , 0 , 4 },\n        {0 , 0 , 5 , 7 , 0 },\n        {0 , 0 , 0 , 0 , 0 },\n        {0 , 2 , 6 , 0 , 0 }\n    };\n\n    int size = 0;\n    for (int i = 0; i &lt; 4; i++)\n        for (int j = 0; j &lt; 5; j++)\n            if (sparseMatrix[i][j] != 0)\n                size++;\n\n    // number of columns in compactMatrix (size) must be\n    // equal to number of non - zero elements in\n    // sparseMatrix\n    int compactMatrix[3][size];\n\n    // Making of new matrix\n    int k = 0;\n    for (int i = 0; i &lt; 4; i++)\n        for (int j = 0; j &lt; 5; j++)\n            if (sparseMatrix[i][j] != 0)\n            {\n                compactMatrix[0][k] = i;\n                compactMatrix[1][k] = j;\n                compactMatrix[2][k] = sparseMatrix[i][j];\n                k++;\n            } \n\n    for (int i=0; i&lt;3; i++)\n    {\n        for (int j=0; j&lt;size; j++)\n            cout &lt;&lt;\" \"&lt;&lt; compactMatrix[i][j];\n        cout &lt;&lt;\"\\n\";\n    }\n    return 0;\n}\n</code></pre> <ul> <li>Using Linked Lists</li> </ul> <pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\n// Node to represent sparse matrix\nstruct Node\n{\n    int value;\n    int row_position;\n    int column_postion;\n    struct Node *next;\n};\n\n// Function to create new node\nvoid create_new_node(struct Node** start, int non_zero_element,int row_index, int column_index )\n{\n    struct Node *temp, *r;\n    temp = *start;\n    if (temp == NULL)\n    {\n        // Create new node dynamically\n        temp = (struct Node *) malloc (sizeof(struct Node));\n        temp-&gt;value = non_zero_element;\n        temp-&gt;row_position = row_index;\n        temp-&gt;column_postion = column_index;\n        temp-&gt;next = NULL;\n        *start = temp;\n    }\n    else\n    {\n        while (temp-&gt;next != NULL)\n            temp = temp-&gt;next;\n        // Create new node dynamically\n        r = (struct Node *) malloc (sizeof(struct Node));\n        r-&gt;value = non_zero_element;\n        r-&gt;row_position = row_index;\n        r-&gt;column_postion = column_index;\n        r-&gt;next = NULL;\n        temp-&gt;next = r;\n    }\n}\n// This function prints contents of linked list\n// starting from start\nvoid PrintList(struct Node* start)\n{\n    struct Node *temp, *r, *s;\n    temp = r = s = start;\n\n    printf(\"row_position: \");\n    while(temp != NULL){\n        printf(\"%d \", temp-&gt;row_position);\n        temp = temp-&gt;next;\n    }\n    printf(\"\\n\");\n    printf(\"column_postion: \");\n    while(r != NULL){\n        printf(\"%d \", r-&gt;column_postion);\n        r = r-&gt;next;\n    }\n    printf(\"\\n\");\n    printf(\"Value: \");\n    while(s != NULL){\n        printf(\"%d \", s-&gt;value);\n        s = s-&gt;next;\n    }\n    printf(\"\\n\");\n}\n// Driver of the program\nint main(){\n// Assume 4x5 sparse matrix\n    int sparseMatric[4][5] =\n    {\n        {0 , 0 , 3 , 0 , 4 },\n        {0 , 0 , 5 , 7 , 0 },\n        {0 , 0 , 0 , 0 , 0 },\n        {0 , 2 , 6 , 0 , 0 }\n    };\n    /* Start with the empty list */\n    struct Node* start = NULL;\n    for (int i = 0; i &lt; 4; i++)\n        for (int j = 0; j &lt; 5; j++)\n            // Pass only those values which are non - zero\n            if (sparseMatric[i][j] != 0)\n                create_new_node(&amp;start, sparseMatric[i][j], i, j);\n    PrintList(start);\n    return 0;\n}\n</code></pre>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#stack","title":"STACK","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#1adt","title":"1.ADT","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#2implementations","title":"2.Implementations","text":"<ul> <li>Linked List</li> <li>Array : The stack model must be well encapsulated.</li> </ul>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#3applications","title":"3.Applications","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#balancing-symbols","title":"Balancing Symbols","text":"<ul> <li>Pseudo Code</li> </ul> <pre><code>Algorithm  {\n    Make an empty stack S;\n    while (read in a character c) {\n        if (c is an opening symbol)\n            Push(c, S);\n        else if (c is a closing symbol) {\n            if (S is empty)  { ERROR; exit; }\n            else  {  /* stack is okay */\n                if  (Top(S) doesn\u2019t match c)  { ERROR, exit; }\n                else  Pop(S);\n            }  /* end else-stack is okay */\n        }  /* end else-if-closing symbol */\n    } /* end while-loop */ \n    if (S is not empty)  ERROR;\n}\n</code></pre> <ul> <li>code in C[Array]</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#define STACKSIZE 30 \nchar stack[ STACKSIZE ]; // Global, but let's go with it\nint top = 0;\nvoid push( char x ) { \n    if( top == STACKSIZE )\n        puts( \"Stack Full\");\n    else\n        stack[ top++ ] = x;\n}\nbool popExpect( char c ) { // compare expected char on top with passed char\n    return top &amp;&amp; c == stack[ --top ];\n}\nbool chk( const char *str ) {\n    char *cp, pairs[] = \"(){}[]\"; // three important pairs\n    bool isGood = true; // optimism\n    for( int i = 0; isGood &amp;&amp; str[ i ]; i++ )\n        // is this char one of the \"special\" ones?\n        if( ( cp = strchr( pairs, str[ i ] ) ) != NULL ) {\n            int off = cp - pairs;\n            // because \"paired\" 0,2,4 are open, 1,3,5 are close\n            if( off%2 == 0 ) // opening\n                push( cp[1] ); // push the close that matches this open\n            else // special closing\n                isGood = popExpect( str[ i ] ); // does this close match?\n        }\n    return isGood &amp;&amp; top == 0;\n}\nint main() {\n    const char *s1 = \"(foobar)({}){bar}[[[(foo)]]]\"; // balanced\n    const char *s2 = \"(foobar)({}){ { bar}[[[(foo)]]]\"; // unbalanced open\n    const char *s3 = \"(foobar)({}){ ] bar}[[[(foo)]]]\"; // unbalanced close\n    puts( chk( s1 ) ? \"Balanced\" : \"Unbalanced\" );\n    puts( chk( s2 ) ? \"Balanced\" : \"Unbalanced\" );\n    puts( chk( s3 ) ? \"Balanced\" : \"Unbalanced\" );\n    return 0;\n}\n</code></pre>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#calculation","title":"Calculation","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#prefix","title":"Prefix","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#infixconvert-to-postfix","title":"Infix\u300cConvert To Postfix\u300d","text":"<ul> <li>Never pop a$ '(' \\(from the stack except when processing a\\) ')' $.</li> <li>Observe that when ' (  ' is not in the stack, its precedence is the highest; but when it is in the stack, its precedence is the lowest.  Define in-stack precedence and incoming precedence for symbols, and each time use the corresponding precedence for comparison. </li> <li>Note:  a \u2013 b \u2013 c will be converted to a b \u2013 c \u2013.  However, \\(2^{2^{3}}\\)must be converted to 2 2 3 ^ ^  ,  not 2 2 ^ 3 ^ since exponentiation associates right to left.</li> </ul> <p>###### Postfix \u300cEasier To Calculate\u300d</p> <p>ps:Tail Recursion! -- compliler will remove the recursion.</p>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#the-queue-adt","title":"The Queue ADT","text":"<ul> <li>A queue is a First-In-First-Out (FIFO) list, that is, an ordered list in which insertions take place at one end and deletions take place at the opposite end.</li> </ul>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#linked-list-implementation","title":"Linked list implementation","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#array-implementation","title":"Array Implementation","text":"<pre><code>struct  QueueRecord {\n    int     Capacity ;   /* max size of queue */\n    int     Front;          /* the front pointer */\n    int     Rear;           /* the rear pointer */\n    int     Size;  /* Optional - the current size of queue */\n    ElementType  *Array;    /* array for queue elements */\n } ; \n</code></pre>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#a-circular-queue","title":"A circular Queue","text":"<ul> <li>Rear[0] Font[1]</li> </ul>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#tree","title":"TREE","text":"<ul> <li>N nodes and N-1 edges</li> <li>node without any son is called  \\(leaf\\)</li> <li>\u4e00\u68f5\u6811\u7684\u5ea6\u662f\u8fd9\u68f5\u6811\u91cc\u6240\u6709\u8282\u70b9\u5ea6\u7684\u6700\u5927\u503c</li> <li>\u4ece\u8282\u70b9 \\(n1\\) \u5230 \\(nk\\) \u7684\u8def\u5f84\u662f\u552f\u4e00\u7684\uff0c\u5176\u957f\u5ea6\u662f\u8def\u5f84\u4e0a\u8fb9\u7684\u6570\u91cf.</li> <li>\u5bf9\u4e8e\u8282\u70b9 \\(ni\\)\uff0c\u5176\u6df1\u5ea6\u4e3a\u4ece\u6839\u5230 \\(ni\\) \u7684\u552f\u4e00\u8def\u5f84\u7684\u957f\u5ea6\\([Depth\\) \\(root = 0]\\)</li> <li>\u5bf9\u4e8e\u8282\u70b9 \\(ni\\)\uff0c\u5176\u9ad8\u5ea6\u4e3a\u4ece \\(ni\\) \u5230\u4e00\u4e2a\u53f6\u8282\u70b9\u7684\u6700\u957f\u957f\u5ea6\\([Height\\) \\(leaf = 0]\\)</li> <li>\u6839\u7684\u9ad8\u5ea6\u79f0\u4e3a\u8fd9\u68f5\u6811\u7684\u9ad8\u5ea6 / \u6df1\u5ea6</li> <li>\u4e00\u4e2a\u8282\u70b9\u7684\u7956\u5148\uff08ancestors\uff09\u662f\u4ece\u6839\u5230\u8fd9\u4e2a\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8282\u70b9</li> <li>\u4e00\u4e2a\u8282\u70b9\u7684\u540e\u88d4\uff08descendants\uff09\u662f\u8fd9\u4e2a\u8282\u70b9\u5b50\u6811\u4e2d\u7684\u6240\u6709\u8282\u70b9</li> </ul>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#implementation","title":"Implementation","text":"<p>FirstChild-NextSibling \u8868\u793a\u6cd5</p> <ul> <li> <p>\u8bb0\u5f55\u7b2c\u4e00\u4e2a\u5b50\u8282\u70b9\u548c\u4e0b\u4e00\u4e2a\u5144\u5f1f\u8282\u70b9</p> </li> <li> <p>\u56e0\u4e3a\u4e00\u68f5\u6811\u7684\u513f\u5b50\u987a\u5e8f\u4e0d\u5b9a\uff0c\u6240\u4ee5\u4e00\u68f5\u6811\u7684\u8868\u793a\u65b9\u5f0f\u4e0d\u552f\u4e00</p> </li> </ul> <pre><code>struct TreeNode {\n    ElementType Element;\n    PtrToNode FirstChild;\n    PtrToNode NextSibling;FirstChildFirfsads\n};\ntypedef struct TreeNode *PtrToNode;\n</code></pre>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#binary-tree","title":"Binary Tree","text":"<ul> <li>\u5b8c\u5168\u4e8c\u53c9\u6811\uff08complete binary tree\uff09\u662f\u6240\u6709\u53f6\u8282\u70b9\u90fd\u5728\u76f8\u90bb\u7684\u4e24\u5c42\u4e0a\u7684\u4e8c\u53c9\u6811</li> <li>\u9664\u4e86\u6700\u540e\u4e00\u5c42\uff0c\u6bcf\u4e00\u5c42\u90fd\u662f\u6ee1\u7684</li> <li>\u6700\u540e\u4e00\u5c42\u7684\u8282\u70b9\u90fd\u9760\u5de6\u6392\u5217</li> <li>\u7b2c i \u5c42\u7684\u8282\u70b9\u6570\u6700\u591a\u4e3a \\(2^{i-1}\\)</li> <li>\u6df1\u5ea6\u4e3a k \u7684\u4e8c\u53c9\u6811\u6700\u591a\u6709\\(2^{k}-1\\) \u4e2a\u8282\u70b9</li> <li>\\(n0\\) \u8868\u793a\u53f6\u8282\u70b9\u6570\uff0c\\(n2\\) \u8868\u793a\u5ea6\u4e3a 2 \u7684\u8282\u70b9\u6570\uff0c\u5219 \\(n0 = n2 +1\\)</li> <li>\u4e8c\u53c9\u6811\u53ef\u4ee5\u901a\u8fc7\u6570\u7ec4\u6765\u8868\u793a</li> <li>\u6839\u4e3a tree[1]</li> <li>\u8282\u70b9 tree[i] \u7684\u5de6\u513f\u5b50\u4e3a tree[2i]\uff0c\u53f3\u513f\u5b50\u4e3a tree[2i+1]</li> <li>\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u6570\u7ec4\u4e2d\u5143\u7d20\u5168\u90e8\u5206\u5e03\u5728 1 ~ n \u4e2d</li> <li>\u8868\u8fbe\u5f0f\u6811\uff08expression tree\uff09</li> </ul>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_1","title":"\u904d\u5386","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#preorderroot-left-right","title":"Preorder\uff1aroot-left-right","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#postorderleft-right-root","title":"Postorder\uff1aleft-right-root","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#inorderleft-root-right","title":"inorder:left-root-right","text":"<ul> <li>level order:</li> </ul> <pre><code>void levelorder(tree_ptr tree) {\n    enqueue(tree);\n    while (queue is not empty) {\n        visit(T = dequeue());\n        for (each child C of T) \n            enqueue(C);\n    }\n}\n</code></pre> <pre><code>//    \u4e8c\u53c9\u6811\u7684\u5b9e\u73b0\uff08C\u8bed\u8a00\uff09\n//    \u94fe\u8868\uff0c\u9012\u5f52\u5b9e\u73b0\ntypedef char Elementtype;    //    \u5b9a\u4e49\u6570\u636e\u7c7b\u578b\uff0c\u53ef\u6839\u636e\u9700\u8981\u81ea\u884c\u5b9a\u5236\ntypedef struct TreeNode * Node;    //    Node\u76f8\u5f53\u4e8estruct treeNode *\n//    \u5b9a\u4e49\u6570\u8282\u70b9\u7ed3\u6784\ntypedef struct TreeNode {\n    Elementtype Element;\n    Node left;    //    \u6811\u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\n    Node right;    //    \u6811\u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\n}TREE,*PTREE;\n\nvoid CreatTree(PTREE *);    //    \u6811\u7684\u5148\u5e8f\u521b\u5efa\u51fd\u6570\nvoid PreOrderTree(PTREE );    //    \u6811\u7684\u524d\u5e8f\u904d\u5386\u51fd\u6570\nvoid InOrderTree(PTREE );    //    \u6811\u7684\u4e2d\u5e8f\u904d\u5386\nvoid PostOrderTree(PTREE );    //    \u6811\u7684\u540e\u5e8f\u904d\u5386\nvoid LeafOfTree(PTREE );    //    \u6253\u5370\u6811\u7684\u53f6\u5b50\u8282\u70b9\u51fd\u6570\nint  Get_Leaf_Num(PTREE );    //    \u83b7\u53d6\u6811\u53f6\u5b50\u8282\u70b9\u4e2a\u6570\nint Get_Height(PTREE );    //    \u83b7\u53d6\u6811\u7684\u9ad8\u5ea6\n\nint main() {\n    PTREE Root;    \n    printf(\"\u8bf7\u5148\u5e8f\u8f93\u5165\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u6570\u636e\uff1a \");\n    CreatTree(&amp;Root);    \n    printf(\"\\n\u524d\u5e8f\u904d\u5386\u7ed3\u679c\u4e3a\uff1a\");\n    PreOrderTree(Root);    \n    printf(\"\\n\u4e2d\u5e8f\u904d\u5386\u7ed3\u679c\u4e3a\uff1a\");\n    InOrderTree(Root);\n    printf(\"\\n\u540e\u5e8f\u904d\u5386\u7ed3\u679c\u4e3a\uff1a\");\n    PostOrderTree(Root);\n    printf(\"\\n\u6253\u5370\u53f6\u5b50\u8282\u70b9\u4e3a\uff1a\");\n    LeafOfTree(Root);\n    printf(\"\\n\u53f6\u5b50\u8282\u70b9\u4e2a\u6570\u4e3a\uff1a%d\", Get_Leaf_Num(Root));\n    printf(\"\\n\u4e8c\u53c9\u6811\u7684\u9ad8\u5ea6\u4e3a\uff1a%d\", Get_Height(Root));\n    printf(\"\\n\");\n    return 0;\n}\n//    \u5b9a\u4e49\u6811\u5148\u5e8f\u521b\u5efa\u51fd\u6570\nvoid CreatTree(PTREE *ROOT){\n  char val = 0;\n  val = getchar();\n  if(wal=='*'){*ROOT=NULL;}\n  else{\n    (*Root)=(PTREE)malloc(sizeof(TREE));\n        if ((*Root) == NULL) {\n            printf(\"\u521b\u5efa\u8282\u70b9\u5931\u8d25\uff0c\u65e0\u6cd5\u5206\u914d\u53ef\u7528\u5185\u5b58...\");\n            exit(-1);\n        }\n            else{\n          (*Root)-&gt;Element =val;\n          CreatTree(&amp;(*Root)-&gt;left);\n          CreatTree(&amp;(*Root)-&gt;right); \n        }\n  }\n\n}\n\n//    \u6811\u7684\u524d\u5e8f\u904d\u5386\u51fd\u6570\u5b9a\u4e49\nvoid PreOrderTree(PTREE Root) {\n    if (Root == NULL)\n        return;\n    else {\n        putchar(Root-&gt;Element);\n        PreOrderTree(Root-&gt;left);\n        PreOrderTree(Root-&gt;right);\n    }\n}\n\n//    \u6811\u7684\u4e2d\u5e8f\u904d\u5386\u51fd\u6570\u5b9a\u4e49\nvoid InOrderTree(PTREE Root) {\n    if (Root == NULL)\n        return;\n    else {\n        InOrderTree(Root-&gt;left);\n        putchar(Root-&gt;Element);\n        InOrderTree(Root-&gt;right);\n    }\n}\n//    \u6811\u7684\u540e\u5e8f\u904d\u5386\u51fd\u6570\u5b9a\u4e49\nvoid PostOrderTree(PTREE Root) {\n    if (Root==NULL) \n        return ;\n    else{\n        PostOrderTree(Root-&gt;left);\n        PostOrderTree(Root-&gt;right);\n        putchar( Root-&gt;Element);\n    }\n}\n//\u6811\u7684\u540e\u5e8f\u904d\u5386\u7684\u5faa\u73af\u5f62\u5f0f\nIterative Program \nvoid iter_postorder\uff08tree_ptr_tree\uff09{\n  stack S = CreateStack(MAX_SIZE);\n  for(;;){\n\n  }\n}\n//    \u6253\u5370\u6811\u7684\u53f6\u5b50\u8282\u70b9\u51fd\u6570\u5b9a\u4e49\nvoid LeafOfTree(PTREE Tree) {\n    if (Tree == NULL)    \n        return ;\n    else {\n        if (Tree-&gt;left == NULL&amp;&amp;Tree-&gt;right == NULL)\n            putchar(Tree-&gt;Element);\n        else {\n            LeafOfTree(Tree-&gt;left);\n            LeafOfTree(Tree-&gt;right);\n        }\n    }  \n}\n//    \u83b7\u53d6\u6811\u7684\u53f6\u5b50\u8282\u70b9\u4e2a\u6570\u51fd\u6570\u5b9a\u4e49\nint Get_Leaf_Num(PTREE Tree) {\n    if (Tree == NULL)\n        return 0;\n    if (Tree-&gt;left == NULL&amp;&amp;Tree-&gt;right == NULL)\n        return 1;\n    //\u9012\u5f52\u6574\u4e2a\u6811\u7684\u53f6\u5b50\u8282\u70b9\u4e2a\u6570 = \u5de6\u5b50\u6811\u53f6\u5b50\u8282\u70b9\u7684\u4e2a\u6570 + \u53f3\u5b50\u6811\u53f6\u5b50\u8282\u70b9\u7684\u4e2a\u6570\n    return Get_Leaf_Num(Tree-&gt;left) + Get_Leaf_Num(Tree-&gt;right);\n}\n//    \u83b7\u53d6\u6811\u9ad8\u7684\u51fd\u6570\u5b9a\u4e49\nint Get_Height(PTREE Tree) {\n    int Height = 0;\n    if (Tree == NULL)\n        return 0;\n    //\u6811\u7684\u9ad8\u5ea6 = max(\u5de6\u5b50\u6811\u7684\u9ad8\u5ea6\uff0c\u53f3\u5b50\u6811\u7684\u9ad8\u5ea6) + 1\n    else\n    {\n        int L_Height = Get_Height(Tree-&gt;left);\n        int R_Height = Get_Height(Tree-&gt;right);\n        Height = L_Height &gt;= R_Height ? L_Height + 1 : R_Height + 1;\n    }\n    return Height;\n}\n</code></pre> <ul> <li>inorder iterative</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n\n// \u5b9a\u4e49\u4e8c\u53c9\u6811\u7ed3\u70b9\nstruct TreeNode {\n    int val;\n    struct TreeNode* left;\n    struct TreeNode* right;\n};\n\n// \u521b\u5efa\u4e00\u4e2a\u4e8c\u53c9\u6811\u7ed3\u70b9\nstruct TreeNode* createNode(int val) {\n    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    newNode-&gt;val = val;\n    newNode-&gt;left = NULL;\n    newNode-&gt;right = NULL;\n    return newNode;\n}\n// \u7ed3\u6784\u4f53\u6a21\u62df\u6808\nstruct TreeNodeStack {\n    struct TreeNode* data;\n    struct TreeNodeStack* next;\n};\n\nstruct TreeNodeStack* createStackNode(struct TreeNode* node) {\n    struct TreeNodeStack* stackNode = (struct TreeNodeStack*)malloc(sizeof(struct TreeNodeStack));\n    stackNode-&gt;data = node;\n    stackNode-&gt;next = NULL;\n    return stackNode;\n}\n\nvoid push(struct TreeNodeStack** stack, struct TreeNode* node) {\n    struct TreeNodeStack* stackNode = createStackNode(node);\n    stackNode-&gt;next = *stack;\n    *stack = stackNode;\n}\n\nstruct TreeNode* pop(struct TreeNodeStack** stack) {\n    if (*stack == NULL) {\n        return NULL;\n    }\n    struct TreeNodeStack* temp = *stack;\n    *stack = (*stack)-&gt;next;\n    struct TreeNode* node = temp-&gt;data;\n    free(temp);\n    return node;\n}\n\nbool isEmpty(struct TreeNodeStack* stack) {\n    return stack == NULL;\n}\n\n// \u4e2d\u5e8f\u904d\u5386\u4e8c\u53c9\u6811\u5e76\u8fd4\u56de\u7ed3\u679c\u4f5c\u4e3a\u6570\u7ec4\nint* inorderTraversal(struct TreeNode* root, int* returnSize) {\n    struct TreeNodeStack* stack = NULL;\n    int* result = (int*)malloc(sizeof(int));\n    int resultSize = 0;\n    struct TreeNode* current = root;\n    while (current != NULL || !isEmpty(stack)) {\n        while (current != NULL) {\n            push(&amp;stack, current);\n            current = current-&gt;left;\n        }\n        current = pop(&amp;stack);\n        result = (int*)realloc(result, (resultSize + 1) * sizeof(int));\n        result[resultSize] = current-&gt;val;\n        resultSize++;\n        current = current-&gt;right;\n    }\n\n    *returnSize = resultSize;\n    return result;\n}\n\n// \u4e3b\u51fd\u6570\nint main() {\n    struct TreeNode* root = createNode(1);\n    root-&gt;right = createNode(2);\n    root-&gt;right-&gt;left = createNode(3);\n\n    printf(\"Inorder Traversal: \");\n    int resultSize;\n    int* result = inorderTraversal(root, &amp;resultSize);\n    for (int i = 0; i &lt; resultSize; i++) {\n        printf(\"%d \", result[i]);\n    }\n    free(result);\n    return 0;\n}\n</code></pre>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#tree_1","title":"\u521b\u5efaTREE","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#1postorder-inorder","title":"1.Postorder &amp;  Inorder \u540e\u5e8f&amp;\u4e2d\u5e8f","text":"<pre><code>BiTree* postInTree(int post[],int in[],int n)  {\n    if (n&lt;=0)   return nullptr;\n    int i=0;\n    while (post[n-1]!=in[i])    i++;    //i\u4e5f\u6b63\u597d\u662f\u5de6\u5b50\u6811\u8282\u70b9\u6570\n    BiTree* nw=new BiTree;\n    nw-&gt;data=in[i];\n    nw-&gt;lc=postInTree(post,in,i);       //\u5efa\u5de6\u5b50\u6811\n    nw-&gt;rc=postInTree(post+i,in+i+1,n-i-1);     //\u5efa\u53f3\u5b50\u6811\n    return nw;\n}\n</code></pre>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#2preorder-inorder","title":"2.preorder &amp; inorder \u524d\u5e8f&amp;\u4e2d\u5e8f","text":"<pre><code>BiTree* preInTree2(int pre[],int in[],int n)  { //\u8fd9\u662f\u7b14\u8bb0\u4e0a\u7684\u6211\u7684\u65b9\u6cd5,n\u662f\u5f53\u524d\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u6570\n    if (n&lt;=0)   return nullptr;\n    int i=0;\n    while (in[i]!=pre[0])   i++;        //\u6b64\u65f6i\u6b63\u597d\u662f\u5de6\u5b50\u6811\u8282\u70b9\u6570\u3002\u5148\u5e8f\u904d\u5386\u7684\u9996\u5143\u7d20\u4e00\u5b9a\u662f\u6839\u8282\u70b9\n    BiTree* nw=new BiTree;\n    nw-&gt;data=in[i];\n    nw-&gt;lc=preInTree2(pre+1,in,i);      //\u5efa\u5de6\u5b50\u6811\uff0c\u5de6\u5b50\u6811\u8282\u70b9i\u4e2a\n    nw-&gt;rc=preInTree2(pre+i+1,in+i+1,n-i-1);        //\u5efa\u53f3\u5b50\u6811\uff0c\u53f3\u5b50\u6811\u8282\u70b9n-i-1\u4e2a\n    return nw;\n}\n</code></pre>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#application","title":"Application","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#1linux-dirtypical-preoder-traversal","title":"1.Linux dir\u300cTypical Preoder Traversal\u300d","text":"<pre><code>static void  ListDir ( DirOrFile D, int Depth )\n{\n    if  ( D is a legitimate entry )   {\n        PrintName (D, Depth );\n        if ( D is a directory )\n            for (each child C of D )\n                ListDir ( C, Depth + 1 );\n    }\n}\n</code></pre>"},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#2calculating-the-size-of-the-directorytypical-postorder-traversal","title":"2.Calculating the size of the directory\u300cTypical Postorder Traversal\u300d","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#3-threader-binary-tree","title":"3.\u7ebf\u7d22\u4e8c\u53c9\u6811 Threader Binary Tree","text":""},{"location":"note/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#binary-search-tree","title":"Binary Search Tree","text":"<ul> <li>Delete</li> </ul> <pre><code>SearchTree Delete(ElementType X, SearchTree T) {\n    Position TmpCell;\n    if (T == NULL) Error(\"not found\");\n    else if (X &lt; T-&gt;Element) T-&gt;Left = Delete(X, T-&gt;Left);\n    else if (x &gt; T-&gt;Element) T-&gt;Right = Delete(X, T-&gt;Right);\n    else {\n        if (T-&gt;Left &amp;&amp; T-&gt;Right) {\n            TmpCell = FindMin(T-&gt;Right);\n            T-&gt;Element = TmpCell-&gt;Element;\n            T-&gt;Right = Delete(T-&gt;Element, T-&gt;Right);\n        } else {\n            TmpCell = T;\n            if (T-&gt;Left == NULL) T = T-&gt;Right;\n            else if (T-&gt;Right == NULL) T = T-&gt;Left;\n            free(TmpCell);\n        }\n    }\n    return T;\n}\n</code></pre> <ul> <li>All binary trees: Equals n nodes pop sequence!!</li> </ul> <p>\\(C_{n}=\\sum_{i=1}^{n} C_{i}C{n-i-1}\\)</p> <ul> <li> <p>\u5b8c\u5168\u4e8c\u53c9\u6811\uff08complete binary tree\uff09\u662f\u6240\u6709\u53f6\u8282\u70b9\u90fd\u5728\u76f8\u90bb\u7684\u4e24\u5c42\u4e0a\u7684\u4e8c\u53c9\u6811</p> </li> <li> <p>\u9664\u4e86\u6700\u540e\u4e00\u5c42\uff0c\u6bcf\u4e00\u5c42\u90fd\u662f\u6ee1\u7684</p> </li> <li> <p>\u6700\u540e\u4e00\u5c42\u7684\u8282\u70b9\u90fd\u9760\u5de6\u6392\u5217</p> </li> <li>\\(2^{h}\\) ~ \\(2^{h+1}-1\\) nodes\\((0,1,2,3- height = 3)\\)</li> <li> <p>\\(h=O(log(n))\\)</p> </li> <li> <p>INSERT</p> </li> </ul> <pre><code>void Insert(ElementType X, MaxHeap H) {\n    if (IsFull(H)) {\n        Error(\"Full Heap\");\n        return;\n    }\n    int i = ++H-&gt;Size;\n    for (; H-&gt;Elements[i/2] &lt; X; i /= 2) {\n        H-&gt;Elements[i] = H-&gt;Elements[i/2];\n    }\n    H-&gt;Elements[i] = X;\n}\n</code></pre> <ul> <li>DELETE</li> </ul> <pre><code>ElementType DeleteMax(MaxHeap H) {\n    if (IsEmpty(H)) {\n        Error(\"Empty Heap\");\n        return H-&gt;Elements[0];\n    }\n    int i, Child;\n    ElementType MaxElement, LastElement;\n    MaxElement = H-&gt;Elements[1];\n    LastElement = H-&gt;Elements[H-&gt;Size--];\n    for (i = 1; i * 2 &lt;= H-&gt;size; i = Child) {\n        Child = i * 2;\n        if (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child + 1] &gt; H-&gt;Elements[Child]) {\n            Child++;\n        }\n        if (LastElement &lt; H-&gt;Elements[Child]) {\n            H-&gt;Elements[i] = H-&gt;Elements[Child];\n        } else {\n            break;\n        }\n    }\n    H-&gt;Elements[i] = LastElement;\n    return MaxElement;\n}\n</code></pre> <p>Question: how to make it a natural stop without using \\(Child != H-&gt;size\\)</p>"},{"location":"note/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/","title":"\u6700\u5927\u5b50\u5e8f\u5217\u548c\u7684\u95ee\u9898","text":""},{"location":"note/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/#on3","title":"O(\\(N^3\\))","text":""},{"location":"note/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/#on2","title":"O(\\(N^2\\))","text":""},{"location":"note/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/#divide-conquer-on-logn","title":"divide &amp; conquer O(N logN)","text":"<p><pre><code>static int\nMaxSubSum(const int A[],int left,int right){\n    int MaxLeftSum, MaxRightSum;\n    int MaxLeftBorderSum, MaxRightBorderSum; \n    int LeftBorderSum, RightBorderSum;\n    int Center, i;\n\n    if( left == right ){\n        if(A[left]&gt;0){\n            return A[left];\n        }\n        else{\n            return 0;\n        }\n    }\n    Center = ( Left +Right ) / 2;\n    MaxLeftSum = MaxSubSum( A, Left, Center ) \n    MaxRightSum = MaxSubSum( A, Center + 1, Right );\n\n    MaxLeftBorderSum = 0; LeftBorderSum = 0;\n\n    for(i=Center;i&gt;=left;i++){\n        LeftBorderSum += A[i];\n        if(leftBorderSum&gt;MaxleftBorderSum){\n            MaxleftBorderSum = LeftBorderSum;\n        }\n    }\n    MaxRightBorderSum = 0; \n    RightBorderSum = 0;\n    for(i=Center+1;i&lt;=Right;i++){\n        RightBorderSum += A[i];\n        if(RightBorderSum &gt; MaxRightBorderSum){\n            MaxRightBOrderSum = RightBorderSum\n        }\n    }\n    return Max(MaxLeftSum,MaxRightSum,MaxLeftBorderSum+MaxRightBorderSum);\n\n}\nint MaxsubsequenceSum( const int A[],intN) {\n    return MaxSubSum( A, 0, N - 1 );\n    }\n</code></pre> </p>"},{"location":"note/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/#on","title":"\u52a8\u6001\u89c4\u5212 O(N)","text":"<pre><code>int MaxSubsequenceSum( const int  A[ ],  int  N ) \n{ \n    int  ThisSum, MaxSum, j; \n    ThisSum = MaxSum = 0; \n    for ( j = 0; j &lt; N; j++ ){ \n        ThisSum += A[ j ]; \n        if( ThisSum &gt; MaxSum ){\n            MaxSum = ThisSum; \n        }\n        else if( ThisSum &lt; 0 ){\n            ThisSum = 0;\n        }\n    } \n    return MaxSum; \n} \n</code></pre>"}]}