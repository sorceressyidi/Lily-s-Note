# 32位间接寻址：

1. 32位间接寻址方式

- 32位比16位多了以下这种寻址方式:
- [寄存器+寄存器*n+常数],其中n=2/4/8
- eax ebx ecx edx esi edi esp ebp 寄存器从8个中任选2个，且两个寄存器可以同名
- 例如:

> mov eax, [ebx + ebi*4+2]

> mov eax, [ebx+esi*4]  
设ebx是数组a的首地址, 下标i用esi表示

则上述语句相当于C语言的: eax = a[i];

````
main()
{
    static short int a[3]={10,20,30}
    int i,sum=0
    for(i=o;i<3;i++){
        sum+=a[i];}
````

### VC里面要查看当前C代码对应的机器语言，可以在按F10开始调试后选菜单:

> View->Debug Windows->Disassembly

TC里面要查看当前C代码对应的机器语言:
> 
> > 先把ary.c([http://cc.zju.edu.cn/bhh/ary.c](http://cc.zju.edu.cn/bhh/ary.c)) 拷到dosbox86\tc,集成环境中选菜单File->Dos Shell->cd\tc

tc  
File->Load->ary.c

Compile->Compile

Compile->Link

File->Quit

td ary.exe

View->CPU

### 这种寻址方式的应用:

````
long a[10]={...};
int i, n=10, sum=0;
for(i=0; i<n; i++)
sum += a[i];
````

- 设ebx=&a[0], esi=0, eax=0, 则上述C代码可转化成以下汇编代码:

  again:  
add eax,[ebx+esi*4]  
add esi, 1  
cmp esi, 10  
jb again

- 32位寻址方式里面，对[]中的两个寄存器几乎不加限制例如:
  
  ebx, ebp, esi, edi,
  
  eax, ecx, edx, esp都可以放到[]里面;
  
  mov eax, [ebx+ebx*4]; 两个寄存器可以任意组合
- movsx:move by sign extension 符号扩充
- movzx:move by zero extension 0扩充

# 段覆盖(segment overriding)

- 通过在操作数前添加一个段前缀(segment prefix)如CS:、DS:、ES:、SS:来强制改变操作数的段址，这就是段覆盖。

> 段地址的隐含:

mov ax, [bx]

mov ax, [si]

mov ax, [di+2]

mov ax, [bx+si]

mov ax, [bx+di+2]

mov ax, [1000h]

上述指令的源操作数都省略了段地址ds。

- [bp], [bp+2], [bp+si+2], [bp+di-1]
  
  等价于ss:[bp], ss:[bp+2], ss:[bp+si+2], ss:[bp+di-1]
- 当[]中包含有寄存器bp时，该变量的段地址一定是ss。
- 
- 例如:  
  `mov ax, [bp+2] 相当于  
    mov ax, ss:[bp+2]`   

> 即利用[bp]访问堆栈的内容

- 默认的段地址是可以改变的, 例如:mov ax, ds:[bp+2].这条指令的源操作数段地址从默认的ss改成了ds。
- 同理,mov ax, [bx+si+2]改成mov ax, cs:[bx+si+2]的话,默认段地址就从ds变成了cs。

# 乘法指令mul

## 8位乘法：被乘数一定是AL 乘积一定是AX

例如mul bl bh表示AX=AL*BH

````
mov al,12h
mov bl,10h
mul bl  ——ax=al*bh=0120h
````

- mul后面所跟的操作数必须是8位寄存器或是8位变量，不能是常数

## 16位乘法：被乘数一定是AX 乘积一定是DX：AX

- :only连接符，连接作用

例如 mul bx表示 FX：AX=bx*ax

````
mov ax,1234h
mov bx,100h 
mul bx ——dx=0012h ax=3400h(00123400h)
````

## 32位乘法：被乘数一定是eax 乘积一定是edx：eax

- 例如 mul ebx表示edx：eax=eax*ebx

# 除法指令div idiv

## ① 16位AX / 8位  = 8位AL(商)..8位AH(余数)

- 意外：bh=1 ax=123h
- （会在发生溢出的指令上方）除法溢出时会在除法指令上方插入int 00h 并调用

## ② 32位DX:AX / 16位 = 16位AX .. 16位DX

````
mov dx,123h
mov ax,3567h
mov bx,1000h
div bx
;AX=1234h DX=0567h
````

## ③ 64位EDX:EAX/32位=32位EAX .. 32位EDX

````
.386
data segment use16
s db"21473647",0 ;7FFF FFFFh
abc dd 0
data ends

code segment use16
main:
    mov ax,data
    mov ds,ax
    mov eax,0 ；被乘数
    mov si,0  ；数组s的下标
again:
    cmp s[si],0;判断是否到达数组的结束标志
    je done
    mov ebx,10
    mul ebx ;必须mul寄存器 edx：eax=乘积 其中edx=0 或写成imul eax，ebx
    mov edx,0
    mov edx,s[si]
    sub dl,'0'
    add eax,edx
    add si,1
    jmp again
done:
````

***

````
.386
data segment use16
abc dd 7FFFFFFFh
s db 10 dup(' '),0Dh,oAh,'$'
data ends

code segment use16
assume cs:code ds:data
main:
    mov ax,data
    mov ds,ax
    mov di,0
    mov eax,[abc]
    mov cx,0
again:
    mov edx,0 ;被除数为EDX：EAX
    mov ebx,10
    div ebx    ；EAX=商 EDX=余数
    add dl,'0'
    push dx
    inc cx
    cmp eax,0
    jne again
pop_again：
    pop dx
    mov s[di],dl
    inc di
    dec cx
    jnz pop_again
    mov ah,9
    mov dx,offset s
    int 21h
    mov ah,4Ch
    int 21h
code ends
end main
    
````



# LEA 取偏移地址

````
lea dx,ds:[1000h];dx=1000h
mov dx,1000h

lea dx,[abc]
mov dx,offset abc

lea dx,ds:[bx+si+3];dx=bc+si+3
mov dx,bx+si+3 ❎(必须是常数表达式 eg 1+2+3)
mov dx,bx

lea eax,[eax+eax*4]
lea eax,[eax+eax*2] 
````

# 5.4

# LDS LES

远指针&近指针

````
1000:0000 78h
1000:0001 56h
1000:0002 34h
1000:0003 12h
dword ptr 1000:[0000]=12345678h
dword ptr 1000:[0000]也可以看作一个远指针，其值为1234:5678h 
````

- 远指针：段地址&偏移地址完整
- 近指针：**only偏移地址 缺少段地址**

  ````
   mov ax,1000h
   mov ds,ax
   mov bx,0
   les di,dword ptr:[bx]
   （dword ptr可省略，因为les规定32位 )
   高16位给es di获得低16位
   es=1234h di=5678h
   
   lds bx,dword ptr ds:[bx];
   ds=1234h,bx=5678h(原来的ds被毁)
  
  
  ````


> 假定把一个远指针1234h:5678h存放到地址1000:0000中，则内存布局如下：

```&p=1000:0000
1000:0000 78h  
1000:0001 56h  
1000:0002 34h  
1000:0003 12h  
设ds=1000h, bx=0
mov di, ds:[bx]; di=5678h
mov es, ds:[bx+2]; es=1234h
les di, dword ptr ds:[bx]
mov al, es:[di]; AL=byte ptr 1234:[5678]

```

> 假定把一个48位的远指针001B:12345678存放到地址1000:0000中，则内存布局如下：

````
1000:0000 78h  
1000:0001 56h  
1000:0002 34h  
1000:0003 12h  
1000:0004 1Bh
1000:0005 00h
假定要把1000:0000中存放的48位远指针取出来，存放到es:edi中，则
mov ax, 1000h
mov ds, ax
mov edi, dword ptr ds:[0]
mov es, word ptr ds:[4]

les edi, fword ptr ds:[0000h]
; es=001Bh, edi=12345678h
;far word（32 位）
````

> 远指针的汇编语言例子

````
data segment
video_addr dw 0000h, 0B800h, 160, 0B800h
;上述定义也可以写成:
;video_addr dd 0B8000000h, 0B80000A0h
data ends
code segment
assume cs:code, ds:data
main:
   mov ax, data
   mov ds, ax
   mov bx, 0
   mov cx, 2
next:
   les di, dword ptr video_addr[bx]
   mov word ptr es:[di], 1741h
   add bx, 4
   sub cx, 1
   jnz next
   mov ah, 1
   int 21h
   mov ah, 4Ch
   int 21h
code ends
end main

````

> 近指针编程例子

````
data segment
video_addr dw 0000h, 160
data ends
code segment
assume cs:code, ds:data

main:
   mov ax, data
   mov ds, ax
   mov ax, 0B800h
   mov es, ax
   mov bx, 0
   mov cx, 2
   
next:
   mov di, video_addr[bx]
   mov word ptr es:[di], 1741h
   add bx, 2
   sub cx, 1
   jnz next
   mov ah, 1
   int 21h
   mov ah, 4Ch
   int 21h
code ends
end main
````

### test

````
test ax,8000h   -test会做and运算但不改变目标操作数的值
jnz msb_is_1    -msb最高位

msb_is_0:
mov dx,0
jmp done

msb_is_1:
mov dx,-1


或者
add ax,0
js msb_is_1
或者 or ax,ax
js msb_is_1
或者
cmp ax,0
jl msb_is_1(符号数的小于则跳)


````

### 符号扩充指令 CBW CWD CDQ

> cbw: convert byte to word

cwd: convert word to double word

cdq: convert double word to quadruple word

````
mov ax,8000h
cwd  -ax=8000h,dx=0FFFFh

mov al,80h
cbw -al=80h,ah=0FFh 即ax=0FF80h

mov eax, 0ABCD1234h
cdq  -把EAX扩充成EDX:EAX
     edx=0FFFFFFFFh, eax=0ABCD1234h
eax不变，edx=-1=0FFFFFFFFh  
````

````
mov al,-4     al=0FCh
cbw           ax=0FFFCh=-4
mov bl,-2     bl=0FEh=-2
idiv bl       al=02h(商) AH=00h（余数）
````

### 新的符号扩充指令: movsx

`movsx ax, al`

- sx:sign extension符号扩充
- 效果等同于cbw
  
  `movsx bx,al`  
  `movsx edx,bl`  
  `movsx edi,bx`

### 零扩充指令: movzx (补零)

- move by zero extention
  
  `movzx ax, al`
  
  `movzx eax, al`
  
  `movzx ebx, cx`

### imul指令用来对符号数做乘法运算

它的第一类用法跟mul指令一样；

````
mov al, 0FFh       
mov bl, 0FFh    
mul bl            
255*255         


mov al, 0FFh
mov bl, 0FFh
imul bl
-1 * -1
````

- mul及imul的第二类用法可以包含2个或3个操作数:
  
  ①mul eax, ebx  
  eax = eax * ebx
  
  ②imul eax, ebx, 3  
  eax = ebx * 3
  
  ①②中的第2个操作数可以是寄存器也可以是变量;
  
  ②中的第3个操作数只能是常数。

### 换码指令：XLAT  (translate) 也称查表指令

- 在xlat执行前必须让**ds:bx**指向表
- al必须赋值为数组的下标，执行xlat后, al=ds:[bx+AL]

````
char t[]="0123456789ABCDEF";
char i;
i = 10;
i = t[i]; 最后i='A'
````

- 设ds=数组t的段地址

````
mov bx, offset t; bx=表的首地址
mov al, 10; AL为下标
xlat; 结果AL='A'
xlat指令要求DS:BX指向数组，AL=数组下标。
执行指令后, AL=数组元素
````

- 例子1

````
.386 ; 表示程序中会用32位的寄存器
data segment use16; use16表示偏移使用16位
t db "0123456789ABCDEF"
x dd 2147483647
data ends

code segment use16
assume cs:code, ds:data
main:
   mov ax, data    ;\
   mov ds, ax      ; / ds:bx->t[0]
   mov bx, offset t;/
   mov ecx, 8
   mov eax, x
next:
   rol eax, 4
   push eax
   and eax, 0Fh
   xlat
   mov ah, 2
   mov dl, al
   int 21h
   pop eax
   sub ecx, 1
   jnz next
   mov ah, 4Ch
   int 21h
code ends
end main
````

ps：这样可以 `sub al,10-'A'`

例子: [http://cc.zju.edu.cn/bhh/xlat_sub.asm](http://cc.zju.edu.cn/bhh/xlat_sub.asm)

### inc: increment

````
mov ax, 3               mov ax, 3
inc ax; AX=AX+1=4       add ax, 1; AX=4
inc指令不影响CF标志位     add会影响CF标志位
````

- inc 速度快，不影响CF指令

````
clc; CF=0               clc
mov ax, 0FFFFh          mov ax, 0FFFFh
inc ax; AX=0, CF=0      add ax, 1;AX=0,CF=1
（对其他标志位有影响：ZF=1 SF=0 OF=0）

again:                  again:
add ax, cx              add ax, cx
jc done                 inc cx
add cx,1                jnc again
jmp again               done:
done:
````

### adc:  add with carry 带进位加

- 计算12345678h + 5678FFFFh

````
mov dx, 1234h
mov ax, 5678h
add ax, 0FFFFh; CF=1
adc dx, 5678h; DX=DX+5678h+CF
````

- 把x和y相加(x、y均为由100字节构成且用小端表示的大数)，结果保存到z中:

````
x db 100 dup(88h)
y db 100 dup(99h)
z db 101 dup(0)
设ds已经赋值为上述数组的段地址
mov cx, 100
mov si, offset x
mov di, offset y
mov bx, offset z
clc
next:
mov al, [si]
adc al, [di]
mov [bx], al
inc si
inc di
inc bx
dec cx
jnz next
adc z[100], 0; 或adc byte ptr [bx], 0
;实现了最后一位的进位
````

- 不能用pushf popf

(2) 减法指令：SUB，SBB，DEC，NEG，CMP

### dec: decrement自减, dec指令不影响CF

````
mov ax, 3
dec ax; AX=AX-1=2
````

### neg:negate 求相反数, 会影响CF,ZF,SF等标志位。

````
mov ax, 1
neg ax; AX=-1=0FFFFh，相当于做减法0-ax

mov ax, 0FFFEh
neg ax; ax=2, CF=1, SF=0, ZF=0
````

> neg ax ≡ (not ax) + 1

-x ≡ ~x + 1

### sbb: subtract with borrow 带借位减

- 例如求56781234h-1111FFFFh的差

````
mov ax, 1234h
sub ax, 0FFFFh; CF=1
mov dx, 5678h
sbb dx, 1111h; DX=5678h-1111h-CF
````

### cmp: cmp与sub的区别是抛弃两数之差, 仅保留标志位状态

````
mov ax, 3
mov bx, 3
cmp ax, bx
````

- 内部是做了减法ax-bx，但是抛弃两数之差，只影响标志位

````
je they_are_equal; 当ZF=1时则跳
jz they_are_equal; 当ZF=1时则跳
因此je≡jz
````

# 非符号数比较相关的跳转指令

- ① ja, jb, jae, jbe都是非符号数比较相关的跳转指令

#### jb: CF=1 故jb≡jc (产生了借位)

#### ja: CF=0 且 ZF=0

````
mov ax, 2
mov bx, 3
cmp ax, bx; CF=1
jb below; 会发生跳转, 它的跳转依据是CF=1
jb ≡ jc
````

- ② jg, jl, jge, jle是符号数比较相关的跳转指令

#### jg:  SF==OF 且 ZF==0  （above）

````
mov ah,7Fh
mov bh,80h
cmp ah,bh    SF=1 OF=1 -> AH>BH
````

#### jge: SF==OF  （above or equal）

````
mov ah,3
mov bh,2
cmp ah,bh  SF=0 OF=0 ->  AH>BH
jg greater

````

#### jl:  SF!=OF **不需要考虑ZF的状态**

````
mov ah,2
mov bh,3
cmp ah,bh ;SF=1 OF=0  -> AH<BH
jl less

mov ah,80h   
mov bh,7Fh
cmp ah,bh

jl less  ;SF=0 OF=1 -> AH<BH
````

- **80h -128**

> cmp ax, bx  
当符号数ax<bx时, SF≠OF  
而ZF=1只可能发生在SF=OF的前提下

#### jle: SF!=OF || (SF==OF && ZF==1)

````
mov ah, 7Fh
mov bh, 80h   ; 7F-80=FF
cmp ah, bh; CF=1, SF=1, OF=1
ja above; 条件不满足
jg greater; 条件满足, 会发生跳转


mov ax, 3
mov bx, 2
cmp ax, bx; AX-BX=1, SF=0, OF=0  AX > BX
mov ah, 7Fh
mov bh, 80h
cmp ah, bh; AH-BH=0FFh, SF=1, OF=1  AX>BX
mov ax, 2
mov bx, 3
cmp ax, bx; AX-BX=FFFFh, SF=1, OF=0AX<BX
mov ah, 80h
mov bh, 7Fh
cmp ah, bh; AH-BH=1, SF=0, OF=1AX<BX
````

#### je 等价于 jz

#### jne等价于jnz

### 小数运算

- fadd  fsub  fmul fdiv 小数的+-*/运算指令
- 由浮点处理器负责执行, 用法请参考主页intel指令集

#### 小数变量的定义:

- pi dd 3.14; 32位小数,相当于float
- r  dq  3.14159; 64位小数, 相当于double q:quadruple 4倍的
- s  dt  3.14159265; 80位小数, 相当于long double
- 在C语言中要输出long double的值需要使用"%Lf"格式

#### CPU内部一共有8个小数寄存器，分别叫做

- st(0)、st(1)、…、st(7)
- 其中st(0)可以简写为st
- 这8个寄存器的宽度均达到80位，相当于C语言中的
  
  long double类型。
- VC里面的long double类型已经退化成double类型。

例子: [http://cc.zju.edu.cn/bhh/float.asm](http://cc.zju.edu.cn/bhh/float.asm)

````
;Turbo Debugger跟踪时，
;点菜单View->Numeric Processor查看小数堆栈

data segment
abc dd 3.14  
xyz dd 2.0
result dd 0
data ends

code segment
assume cs:code, ds:data
main:
   mov ax, data
   mov ds, ax
   fld [abc]
   ; 把3.14载入到小数堆栈 -->st(0)=3.14 自动将原先的小数转为80位放入st（0）
   fld xyz
   ; 把2.0载入到小数堆栈   --> st(1)=3.14 st(0)=2.0   
   fmul st, st(1); 两数相乘
   fstp result  ; 保存结果到result，并弹出
   fstp st      ; 弹出小数堆栈中残余的值
   mov ah, 4Ch
   int 21h
code ends
end main

main :
    mov ax,data
    mov ds,ax
    fld [abc]
    fmul [abc]
````

- fild 将整数载入小数堆栈
- eg:将3.14压入小数堆栈站中，如果指向0，那么压入7（此时st[7]变成逻辑上的st[0]）
- 此时st[7]—--物理编号[通过读取浮点状态寄存器的第11位至第13位，可得知当前指针处的物理编号]
- 再压入2.0 则st[7]->st[1];st[6]->st[0]
- 即最后一个压入的值永远保存在逻辑编号st[0]中

# 除法溢出

### 除法溢出的两种情形:

①

````
mov ax, 1234h
mov bh, 0
div bh; 此时因为除以0, 所以会发生除法溢出
````

②

````
mov ax, 123h
mov bh, 1
div bh; 此时由于商无法保存到AL中, 因此也会发生溢出。
````

````
data segment
old_00h dw 0, 0
data ends

code segment
assume cs:code, ds:data
int_00h:
   ;mov bh, 80h
   push bp
   mov bp,sp
   add word ptr [bp+2],2   
   ;[bp+2]->offset 'div bh'
   ；则会返回到back而不执行div bh
   pop bp
   iret
main:
   mov ax, data
   mov ds, ax
   xor bx, bx
   mov es, bx
   mov ax, es:[bx]
   mov dx, es:[bx+2]
   mov old_00h[0], ax
   mov old_00h[2], dx
   mov word ptr es:[bx], offset int_00h
   mov es:[bx+2], cs
   mov ax, 123h
here:
   div bh
back:
   mov ah, 2
   mov dl, 'B'
   int 21h
   mov ax, old_00h[0]
   mov dx, old_00h[2]
   mov es:[0], ax
   mov es:[2], dx
   mov ah, 4Ch
   int 21h
code ends
end main
````

### 除法溢出时会发生什么?

````
mov ax, 123h
mov ch, 1
除法溢出时会在此处插入int 00h并执行
在dos系统下, int 00h会显示溢出信息并终止程序运行
div ch; 此处发生除法溢出
mov ah, 4Ch; \ 这2条指令将不可能被执行到
int 21h     ; /
````

- 不过,我们可以通过修改0:0处的远指针(即int 00h的目标函数地址或中断向量)把我们自己的函数如int_00h与int 00h中断进行绑定,从而使得int 00h发生时让cpu来执行我们自己定义的中断函数int_00h。以下代码通过自定义中断函数int_00h改变ch的值使其等于10h, 于是当cpu从中断函数返回并继续执行div ch时能正常执行除法而不发生溢出:
- [http://cc.zju.edu.cn/bhh/divov.asm](http://cc.zju.edu.cn/bhh/divov.asm)

# 

## 

> not:单目运算符 not ax =~ax  
test:**丢弃运算结果**，保留标志位状态；本质上是and指令

````
mov ax, 9234h
test ax, 8000h; ZF=0, AX=9234h
jnz msb_is_one; most significant bit最高位
test和and的关系相当于cmp和sub的关系。
````

- 判断某个寄存器是否为0的几种方法:

````
test cl, cl
or cl, cl
and cl, cl
or cl, 0
cmp cl, 0
````

> 上述每条指令后面都可以跟jz或jnz来判断CL是否为0。

## 移位指令

> shl, shr, sal, sar, rol,ror, rcl, rcr
> 
> > shl shr 逻辑左移、逻辑右移[针对非符号数]  
sal sar 算术左移、算术右移[针对符号数]  
sal=shl 均右边补零  
shr右移时左边永远补零，*sar右移时左边补上元素的最高位*

````
mov ah, 1011 0110B
rol ah, 1;  AH=0110 1101, CF=1
sal: shift arithmetic left 算术左移
mov ah,11111100B;AH=-4
sar ah,2;AH=11111111 AH=-2
````

- sar对负数右移时左边要补1

> rcl: rotate through carry left 带进位循环左移

rcr: rotate through carry right带进位循环右移

````
mov ah,0B6h
clc       ;CF=0
rcl ah,1  ;CF=原来最高位的值 ah最地位会变成原CF的值
          ;ah=01101100 CF=1
          
mov ah, 0B6h
stc         ; CF=1
rcl ah, 1   ; CF=1 AH=1011 0110 移位前
            ; CF=1 AH=0110 1101 移位后
            
mov ah, 0B6h
stc         ; CF=1
rcr ah, 1   ; AH=1011 0110  CF=1移位前
            ; AH=1101 1011  CF=0移位后
            
mov ah,0B6h
stc
rcl ah, 1;  CF=1 AH=0110 1101
            dx   ax
````

- 要把1234 ABCDh逻辑左移3位

[相当于]

> mov eax,1234ABCDh  
shl eax,1

````
mov dx, 1234h
mov ax, 0ABCDh
mov cx, 3
next:
shl ax, 1; CF=1
rcl dx, 1; CF会补DX右侧的空洞
dec cx
jnz next
````

````
解法1:
设ax=0ABCDh
and ax, 0E000h

mov dx, 1234h
mov ax, 0ABCDh
mov cl, 3
shl dx, cl
mov bx, ax
shl ax, cl
mov cl, 13
shr bx, cl
or dx, bx
解法2:
mov dx, 1234h
mov ax, 0ABCDh
mov cx, 3
next:
shl ax, 1
rcl dx, 1
dec cx
jnz next

````

> shl, shr, rol, ror, rcl, rcr**最后移出去的那一位一定在CF中。**

- 假定要把AX中的16位值转化成二进制输出:

````
解法1:
mov cx, 16
next:
shl ax, 1
jc is_1
is_0:
mov dl, '0'
jmp output
is_1:
mov dl, '1'
output:
push ax
mov ah, 2
int 21h
pop ax
dec cx
jnz next
解法2:
mov cx, 16
next:
shl ax, 1
mov dl, '0'
adc dl, 0
output:
push ax
mov ah, 2
int 21h
pop ax
dec cx
jnz next
````

- C语言有2个库函数用来做循环左移及右移:

````
unsigned int _rotl(unsigned int x, int n)
unsigned int _rotr(unsigned int x, int n)
unsigned int _rotl(unsigned int x, int n)
{
    return x << n  | x >> sizeof(x)*8-n;
}
````

# 字符串操作指令

## 字符串传送指令：MOVSB，MOVSW，MOVSD

> rep movsb

其中rep表示repeat，s表示string，b表示byte

- 在执行此指令前要做以下准备工作：

````
①ds:si->源字符串(si就是source index)
②es:di->目标字符串(di就是destination index)
③cx=移动次数
④DF=0即方向标志设成正方向(用指令cld)
````

> rep movsb所做的操作如下:

````
again:
if(cx == 0)
   goto done;
byte ptr es:[di] = byte ptr ds:[si]
if(df==0)
{si++; di++;}
else
{si--; di--;}
cx--
goto again
done:
````

> 单独movsb指令所做的操作如下:[byte]

````
byte ptr es:[di] = byte ptr ds:[si]
if(df==0)
{si++; di++;}
else
{si--; di--;}
````

- 例子: 要把以下左侧4个字节复制到右侧

````
1000:0000 'A'        2000:0000  'A'
1000:0001 'B'        2000:0001  'B'
1000:0002 'C'        2000:0002  'C'
1000:0003 00         2000:0003  00
````

- 则程序可以这样写:

````
mov ax, 1000h
mov ds, ax
mov si, 0      ; mov si, 3
mov ax, 2000h
mov es, ax
mov di, 0      ; mov di, 3
mov cx, 4
cld             ; std
rep movsb
循环结束时         循环结束时
si=4              si=FFFF
di=4              di=FFFF
cx=0              cx=0
````

> rep movsw的操作过程:[word]

````
again:
if(cx == 0)
   goto done;
word ptr es:[di] = word ptr ds:[si]
if(df==0)
{si+=2; di+=2;}
else
{si-=2; di-=2;}
cx--
goto again
done:
````

rep movsd的操作过程:[dword]

````
again:
if(cx == 0)
   goto done;
dword ptr es:[di] = dword ptr ds:[si]
if(df==0)
{si+=4; di+=4;}
else
{si-=4; di-=4;}
cx--
goto again
done:
````

> 在32位系统下, 假定ds:esi->源内存块, es:edi->目标块, DF=0, 则当要复制的字节数ecx不是4的倍数时，可以做如下处理:

````
push ecx
shr ecx, 2
rep movsd
pop ecx
and ecx, 3; 相当于ecx = ecx % 4
rep movsb
````

- 1101B=1100+01

## 字符串比较指令：CMPSB，CMPSW，CMPSD

### cmpsb [jz je]

> 比较byte ptr ds:[si]与byte ptr es:[di]

当DF=0时，si++，di++

当DF=1时，si--，di--

- 自动对si di更新[为下一次移动准备]

### repe cmpsb

- 若本次比较相等则继续比较下一个
- repeat if equal

````
again:
if(cx == 0) goto done;
temp=byte ptr ds:[si]-byte ptr es:[di]
old_fl=FL
当DF=0时，si++，di++
当DF=1时，si--，di--
cx--
FL=old_fl
if (ZF==1) goto again
done:
````

> cx!=0 也可能提前结束循环

### repne cmpsb

- (若本次比较不等则继续比较下一个)
- repeat if not equal

````
again:
if(cx == 0) goto done;
temp=byte ptr ds:[si]-byte ptr es:[di]
old_fl=FL
当DF=0时，si++，di++
当DF=1时，si--，di--
cx--
FL=old_fl
if (ZF==0) goto again
done:
````

- 例子：compare左右两个字符串

````
1000:10A0	‘A’		2000:20F0	‘A’ 
1000:10A1	‘B’		2000:20F1	‘B’ 
1000:10A2	‘C’		2000:20F2	‘C’ 
1000:10A3	‘1’		2000:20F3	‘4’ 
1000:10A4	‘2’		2000:20F4	‘5’ 
1000:10A5	‘3’		2000:20F5	‘6’ 
````

> 设ds=1000h, si=10A0h, es=2000h, di=20F0h

cx=6, DF=0

- 不能根据cx=0推出字符串想等
- 最后一个 **[old]ZF=1** 即可

````
repe cmpsb     
je equal; 全等
dec si       
dec di   
...    
equal:
````

- 最后一次比较，si与di都在下一个指向处

## 字符串扫描指令：scasb，scasw, scasd

### scasb:

````
cmp al, es:[di]
di++; (当DF=1时，为di--)
````

### repne scasb:

````
next:
  if(cx == 0) goto done;
  cmp al, es:[di]
      di++; 当DF=1时，为di--
      cx--
  je done
  goto next
done:
````

- 例子: 假定从地址1000:2000开始存放一个字符串，请计算该字符串的长度并存放到CX中。假定字符串以ASCII码0结束，字符串长度不包括0。

````
mov ax, 1000h
mov es, ax
mov di, 2000h; ES:DI->目标串
mov cx, 0FFFFh; CX=最多找FFFF次
mov al, 0; AL=待找的字符
cld       ; DF=0，表示正方向
repne scasb; again:
not cx      ; 相当于cx=FFFF-cx
dec cx
;上述两条指令也可以替换成以下两条指令:
;inc cx
;not cx
        
````

- **not cx相当于cx=FFFF-cx**

### repe scasb

- 假定从地址1000:0000起存放以下字符串：
  
  "###ABC"，现要求跳过前面的#，把后面剩余的
  
  全部字符复制到2000:0000中

> 假定es=1000h, di=0, cx=7, 则

````
mov al, '#'
cld
repe scasb
dec di; ES:DI->"ABC"
inc cx; CX=4
push es
pop ds; DS=ES
push di
pop si; SI=DI
mov ax, 2000h
mov es, ax
mov di, 0
rep movsb
````

# 字符串操作指令stosb及lodsb

## stosb, stosw, stosd

```stosb:
es:[di] = AL
di++; DF=1时为di--
```

> rep stosb: 循环CX次stosb

````
again:
if(cx == 0) goto done;
es:[di] = al
di++; 当DF=1时, 为DI--
cx--
goto again;
done:
````

````
memset(void *t,int value,int n);
double x[100];
memset(&x,0,sizeof(x))
````

- 把从地址1000:10A0开始共100h个字节的内存单元全部填0

````
mov ax, 1000h
mov es, ax; ES=1000h
mov di, 10A0h                    	mov di,10A0h
mov cx, 100h     mov cx, 80h    	mov cx,40h
cld                cld             cld
xor al, al       xor ax, ax     	xor eax, eax
rep stosb        rep stosw       	rep stosd

````

## lodsb

````
al=ds:[si]
SI++;当DF=1时, 为SI--
````

- 例: 设ds:si-> "##AB#12#XY"且es:di指向一个空的数组, CX=11通过编程过滤#最后使得es:di ->"AB12XY"

````
cld
again:
   lodsb ; AL=DS:[SI], SI++
         ; mov al, ds:[si]
         ; inc si
   cmp al, '#'
   je   next
   stosb ; ES:[DI]=AL, DI++
         ; mov es:[di], al
         ; inc di
next:
   dec cx
   jnz again
````



````
strlen:
    push bp
    mov bp,sp
    push di
    push ds

    mov di,[bp+4]
    mov ax,data
    mov ds,ax
    mov es,ax
    mov cx,0FFFFh
    xor al,al
    cld
    repne scasb
    inc cx
    not cx
    mov ax,cx
   
    pop ds
    pop di
    mov sp,bp
    pop bp
    ret
_memcpy:
    push bp
    mov bp,sp
    push es
    push ds
    push si
    push di
    mov ax,data
    mov es,ax
    mov ds,ax
    mov si,word ptr [bp+6]
    mov di,word ptr [bp+4]
    mov cx,word ptr [bp+8]
    cld
    rep movsb
    pop di
    pop si
    pop ds
    pop es
    mov sp,bp
    pop bp
    ret
_strncpy:
    push bp
    mov bp,sp
    push es
    push ds
    push si
    push di
    mov si, word ptr [bp+6]
    mov di,word ptr [bp+4]
    push si
    call _strlen
    pop cx
    cmp ax,[bp+8]
    jl tricky_form
    mov cx,word ptr [bp+8]
    cld
    rep movsb
    tricky_form:
    mov dx,[bp+8]
    sub dx,ax
    mov cx,ax
    cld
    rep movsb
    mov cx,dx
    mov ax,0
    cld
    rep stosb
    pop di
    pop si
    pop ds
    pop es
    mov sp,bp
    pop bp
    ret
_memset:
    push bp
    mov bp,sp
    push es
    push di
    mov ax,data
    mov es,ax
    mov di,[bp+4]
    mov ax,[bp+6]
    mov cx,[bp+8]
    cld
    rep stosb
    pop di
    pop es
    mov sp,bp
    pop bp
    ret
   
_clrscr:
    push es
    push di
    mov ax,0B800h
    mov es,ax
    mov di,0
    mov ax,0000h
    mov cx,2000
again:
    mov es:[di],ax
    add di,2
    sub cx,1
    jnz again
    pop di
    pop es
    ret
````











# 控制转移指令

## jmp的3种类型

①jmp short target			; 短跳

②jmp near ptr target 	; 近跳

③jmp far ptr target  	; 远跳

- 一般情况下，编译器会自动度量跳跃的距离，因此我们在
  
  写源程序的时候不需要加上short、near ptr、far ptr等类型修饰
- 即上述三种写法一律可以简化为jmp target。

## 短跳指令[only one byte]

### 短跳指令的格式

jmp 偏移地址或标号

- **以下条件跳转指令也都属于短跳: jc jnc jo jno js jns jz jnz ja jb jae jbe jg jge jl jle jp jnp**

### 短跳指令的机器码

````
     地址            机器码   汇编指令  
    1D3E:0090     ...
    1D3E:00F0
    1D3E:0100     EB06     jmp  0108h
    1D3E:0102     B402     mov  ah，2
    1D3E:0104     B241     mov  dl, 41h
    1D3E:0106     CD21     int  21h
    1D3E:0108     B44C     mov  ah，4Ch
    1D3E:010A     CD21     int  21h
    
````

> EB06 :06=108-102(目标地址108和下一条指令的差[取出本条指令后，ip立刻变成0102（下一条指令的偏移地址）]

- 例:自我移动的代码 [http://cc.zju.edu.cn/bhh/movcode.asm](http://cc.zju.edu.cn/bhh/movcode.asm)

````
code segment
assume cs:code, ds:code, es:code
main:
   push cs
   pop ds; DS=CS
   push cs
   pop es; ES=CS
   cld
   mov ah, 2
   mov dl, 'A'
   int 21h
   mov si, offset begin_flag
   mov di, 1000h
   mov cx, offset end_flag-offset begin_flag
   rep movsb
   mov cx, offset end_flag - offset main
   mov di, offset main
   mov bx, 1000h
   jmp bx
begin_flag:
   jmp next
next:
   mov al, 0
   rep stosb
   mov ah, 2
   mov dl, 'B'
   int 21h
   mov ah, 4Ch
   int 21h
end_flag:
code ends
end main
````

- 5.18 7.11 --nop
- 例: 修改printf让它做加法运算[http://cc.zju.edu.cn/bhh/printf.c](http://cc.zju.edu.cn/bhh/printf.c)

````
/* 用DosBoxTc编译，菜单Options->Compiler->Model->Tiny
    Compile->Compile to OBJ
    Compile->Link EXE file
    Run->Run
    Run->User Screen
 */

extern int printf();
int f(int a, int b)
{
   return a+b;
}
void zzz(void)
{
}
main()
{
    // short int a[3]={10,20,30}
    int n;
    n=&a[2]-&a[0] --eg.(1004-1000)/2
    //非char星号相减

   char buf[100];
   char *p = (char *)printf;
   char *q = (char *)f;
   int n = (char *)zzz - (char *)f;
   int y;
   memcpy(buf, p, n);
   memcpy(p, q, n);
   y = printf(10, 20);
   memcpy(p, buf, n);
   printf("y=%d\n", y);
}
````

- C语言，从右向左push
- #progma comment（linker,"/SECTION:.text,RWX")

### 短跳太远跳不过去的解决办法

````
cmp ax, bx
（je  equal; jump out of range）
jne not_equal
jmp equal; 近跳
not_equal:
...; 假定这里省略指令的机器码总长度超过7Fh字节
equal:
...
````

- jmp 如此设计 可以使新程序脱离依赖老程序的部分

````
rom读取主引导区0道/0头/1扇区到0000:7C00处
jmp 0:7C00
主引导区代码会找到C盘里面有的操作系统
它会移动自己的代码到0:600处
接下去它读取C盘的第一个扇区到0:7c00处
jmp 0:7C00
它读取ntldr程序到内存
````

## 近跳指令[two bytes]

- ①近跳指令的3种格式

````
jmp 偏移地址或标号   ; 如jmp 1000h
jmp 16位寄存器		; 如jmp bx
jmp 16位变量  		; 如jmp word ptr [addr]
````

- ②近跳指令的机器码

````
 地址        机器码      汇编指令    
1D3E:0100   E9FD1E      jmp  2000h
近跳指令的第1个字节=E9
后面2个字节=Δ=目标地址-下条指令的偏移地址
=2000h-103h=1EFDh
1D3E:0103   B44C         mov  ah，4Ch
1D3E:0105   CD21         int  21h
...
1D3E:2000   ...
````

````
byte ptr ; 1字节
word ptr ; 2字节
dword ptr; 4字节(32位整数或float类型小数)
fword ptr; 6字节(4字节偏移地址+2字节段地址)
qword ptr; 8字节(64位整数或double类型小数)
tbyte ptr; 10字节(long double类型的80位小数)
short     用来修饰一个短的标号
near ptr 用来修饰一个近的标号
far ptr  用来修饰一个远的标号
````

## 远跳指令[跨段跳跃]

- ①远跳指令的2种格式

````
jmp 段地址:偏移地址
jmp dword ptr 32位变量
````

- ②远跳指令的机器码
  
  `jmp 1234h:5678h; 机器码为0EAh,78h,56h,34h,12h`

> 远跳没有用△，而是直接地址

远跳到某个常数地址时,在源程序中不能直接用jmp指令，而应该改用机器码0EAh定义，如:

````
db 0EAh
dw 5678h
dw 1234h

db 0EAh
dd 0FFFF0000h
;或 dw 0000h
;dw 0FFFFh
````

> 上述3行定义合在一起表示jmp 1234h:5678h

`db 0E06`

- 例: jmp dword ptr 32位变量的用法

````
mov word ptr ds:[bx],1234h
mov word ptr ds:[bx+2],5678h
jmp dword ptr ds:[bx] ;jmp 5678h:1234h
````

````
data segment
addr dw 0000h, 0FFFFh 
;或写成addr dd 0FFFF0000h
data ends
code segment
assume cs:code, ds:data
main:
mov ax, data
mov ds, ax
jmp dword ptr [addr] 
;相当于jmp FFFF:0000
code ends
end main
````

> 例: 演示短跳、近跳、远跳 [http://cc.zju.edu.cn/bhh/jmp.asm](http://cc.zju.edu.cn/bhh/jmp.asm)

````
code segment
assume cs:code
main:
   jmp next; jmp short next
exit:
   mov ah, 4Ch
   int 21h
next:
   mov ah, 2
   mov dl, 'A'
   int 21h
   jmp abc; jmp near ptr abc
   db 200h dup(0)
abc:
   jmp far ptr away; jmp far ptr away
   ;away在另一个code段内
code ends

fff segment
assume cs:fff
away:
   mov ah, 2
   mov dl, 'F'
   int 21h
   jmp far ptr exit; jmp far ptr exit
   ;or 将exit： 改为 exit lable far
fff ends
end main
````

> 

````
1000:2000 call 1234:5678  ;跨段跳远
cpu会做一下动作：
[1]push cs
[2]push 2005h
[3]jmp 1234:5678h
;一定先压入段地址，再压入偏移地址  WHY?5.18最后一段
1000:2005 mov ah,4Ch

1234:5678 ...
1234:5688 retf
cpu 在retf时会做以下动作
[1]pop ip;
[2]pop cs;
````